!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).GW=t.GW||{})}(this,(function(t){"use strict";const e=[0,0,1,0,0,1,0,1,1,0,1,1];const i="\n#version 300 es\nin uvec2 position;\nin uvec2 uv;\nin uint style;\nout vec2 fsUv;\nflat out uint fsStyle;\nuniform highp uvec2 tileSize;\nuniform uvec2 viewportSize;\nvoid main() {\n\tivec2 positionPx = ivec2(position * tileSize);\n\tvec2 positionNdc = (vec2(positionPx * 2) / vec2(viewportSize))-1.0;\n\tpositionNdc.y *= -1.0;\n\tgl_Position = vec4(positionNdc, 0.0, 1.0);\n\tfsUv = vec2(uv);\n\tfsStyle = style;\n}".trim(),s="\n#version 300 es\nprecision highp float;\nin vec2 fsUv;\nflat in uint fsStyle;\nout vec4 fragColor;\nuniform sampler2D font;\nuniform highp uvec2 tileSize;\nvoid main() {\n\tuvec2 fontTiles = uvec2(textureSize(font, 0)) / tileSize;\n\n\tuint glyph = (fsStyle & uint(0xFF000000)) >> 24;\n\tuint glyphX = (glyph & uint(0xF));\n\tuint glyphY = (glyph >> 4);\n\tuvec2 fontPosition = uvec2(glyphX, glyphY);\n\n\tuvec2 fontPx = (tileSize * fontPosition) + uvec2(vec2(tileSize) * fsUv);\n\tvec3 texel = texelFetch(font, ivec2(fontPx), 0).rgb;\n\n\tfloat s = 15.0;\n\tuint fr = (fsStyle & uint(0xF00)) >> 8;\n\tuint fg = (fsStyle & uint(0x0F0)) >> 4;\n\tuint fb = (fsStyle & uint(0x00F)) >> 0;\n\tvec3 fgRgb = vec3(fr, fg, fb) / s;\n  \n\tuint br = (fsStyle & uint(0xF00000)) >> 20;\n\tuint bg = (fsStyle & uint(0x0F0000)) >> 16;\n\tuint bb = (fsStyle & uint(0x00F000)) >> 12;\n\tvec3 bgRgb = vec3(br, bg, bb) / s;\n  \n\tfragColor = vec4(mix(bgRgb, fgRgb, texel), 1.0);\n}".trim();class r{constructor(t){if(this._data=new Uint32Array,this._buffers={},this._attribs={},this._uniforms={},this._renderRequested=!1,this._autoRender=!0,this._width=50,this._height=25,!t.glyphs)throw new Error("You must supply glyphs for the canvas.");this._gl=this._initGL(t.node),this._configure(t)}get node(){return this._gl.canvas}get width(){return this._width}get height(){return this._height}get tileWidth(){return this._glyphs.tileWidth}get tileHeight(){return this._glyphs.tileHeight}get pxWidth(){return this.node.width}get pxHeight(){return this.node.height}get glyphs(){return this._glyphs}set glyphs(t){const e=this._gl,i=this._uniforms;(t!==this._glyphs||t.needsUpdate)&&(t!==this._glyphs&&(this._glyphs=t,this.resize(this._width,this._height),e.uniform2uiv(i.tileSize,[this.tileWidth,this.tileHeight])),this._uploadGlyphs())}_configure(t){this._width=t.width||this._width,this._height=t.height||this._height,this._autoRender=!1!==t.render,this.glyphs=t.glyphs}resize(t,e){this._width=t,this._height=e;const i=this.node;i.width=this._width*this.tileWidth,i.height=this._height*this.tileHeight;const s=this._gl,r=this._uniforms;s.viewport(0,0,i.width,i.height),s.uniform2ui(r.viewportSize,i.width,i.height),this._createGeometry(),this._createData()}draw(t,e,i,s,r){let h=e*this._width+t;h*=6;const n=((i&=255)<<24)+((r&=4095)<<12)+(s&=4095);this._data[h+2]=n,this._data[h+5]=n,this._requestRender()}copy(t){t.data.forEach(((t,e)=>{const i=6*e;this._data[i+2]=t,this._data[i+5]=t})),this._requestRender()}copyTo(t){const e=this.width*this.height,i=t.data;for(let t=0;t<e;++t){const e=6*t;i[t]=this._data[e+2]}}_initGL(t){if("string"==typeof t){const e=document.getElementById(t);if(!e)throw new Error("Failed to find canvas with id:"+t);if(!(e instanceof HTMLCanvasElement))throw new Error("Canvas: node must be a canvas element.");t=e}else t||(t=document.createElement("canvas"));let e=t.getContext("webgl2");if(!e)throw new Error("WebGL 2 not supported");const r=function(t,...e){const i=t.createProgram();if([t.VERTEX_SHADER,t.FRAGMENT_SHADER].forEach(((s,r)=>{const h=t.createShader(s);if(t.shaderSource(h,e[r]),t.compileShader(h),!t.getShaderParameter(h,t.COMPILE_STATUS))throw new Error(t.getShaderInfoLog(h));t.attachShader(i,h)})),t.linkProgram(i),!t.getProgramParameter(i,t.LINK_STATUS))throw new Error(t.getProgramInfoLog(i));return i}(e,i,s);e.useProgram(r);const h=e.getProgramParameter(r,e.ACTIVE_ATTRIBUTES);for(let t=0;t<h;t++){e.enableVertexAttribArray(t);let i=e.getActiveAttrib(r,t);this._attribs[i.name]=t}const n=e.getProgramParameter(r,e.ACTIVE_UNIFORMS);for(let t=0;t<n;t++){let i=e.getActiveUniform(r,t);this._uniforms[i.name]=e.getUniformLocation(r,i.name)}return e.uniform1i(this._uniforms.font,0),this._texture=function(t){let e=t.createTexture();return t.bindTexture(t.TEXTURE_2D,e),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.NEAREST),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.NEAREST),e}(e),e}_createGeometry(){const t=this._gl;this._buffers.position&&t.deleteBuffer(this._buffers.position),this._buffers.uv&&t.deleteBuffer(this._buffers.uv);let i=function(t,i,s,r){let h=s*r,n=new Uint16Array(h*e.length),a=new Uint8Array(h*e.length),o=0;for(let t=0;t<r;t++)for(let i=0;i<s;i++)e.forEach((e=>{n[o]=(o%2?t:i)+e,a[o]=e,o++}));const u=t.createBuffer();t.bindBuffer(t.ARRAY_BUFFER,u),t.vertexAttribIPointer(i.position,2,t.UNSIGNED_SHORT,0,0),t.bufferData(t.ARRAY_BUFFER,n,t.STATIC_DRAW);const l=t.createBuffer();return t.bindBuffer(t.ARRAY_BUFFER,l),t.vertexAttribIPointer(i.uv,2,t.UNSIGNED_BYTE,0,0),t.bufferData(t.ARRAY_BUFFER,a,t.STATIC_DRAW),{position:u,uv:l}}(t,this._attribs,this._width,this._height);Object.assign(this._buffers,i)}_createData(){const t=this._gl,e=this._attribs,i=this._width*this._height;this._buffers.style&&t.deleteBuffer(this._buffers.style),this._data=new Uint32Array(6*i);const s=t.createBuffer();t.bindBuffer(t.ARRAY_BUFFER,s),t.vertexAttribIPointer(e.style,1,t.UNSIGNED_INT,0,0),Object.assign(this._buffers,{style:s})}_requestRender(){!this._renderRequested&&this._autoRender&&(this._renderRequested=!0,requestAnimationFrame((()=>this.render())))}render(){const t=this._gl;this._glyphs.needsUpdate&&this._uploadGlyphs(),this._renderRequested=!1,t.bindBuffer(t.ARRAY_BUFFER,this._buffers.style),t.bufferData(t.ARRAY_BUFFER,this._data,t.DYNAMIC_DRAW),t.drawArrays(t.TRIANGLES,0,this._width*this._height*6)}_uploadGlyphs(){if(!this._glyphs.needsUpdate)return;const t=this._gl;t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,this._texture),t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,this._glyphs.node),this._requestRender(),this._glyphs.needsUpdate=!1}}class h{constructor(t={}){this._tileWidth=12,this._tileHeight=16,this.needsUpdate=!0,this._map={},t.font=t.font||"monospace",this._node=document.createElement("canvas"),this._ctx=this.node.getContext("2d"),this._configure(t)}static fromImage(t){if("string"==typeof t){if(t.startsWith("data:"))throw new Error("Glyph: You must load a data string into an image element and use that.");const e=document.getElementById(t);if(!e)throw new Error("Glyph: Failed to find image element with id:"+t);t=e}const e=new this({tileWidth:t.width/16,tileHeight:t.height/16});return e._ctx.drawImage(t,0,0),e}static fromFont(t){"string"==typeof t&&(t={font:t});const e=new this(t),i=t.basicOnly||t.basic||!1;return e._initGlyphs(i),e}get node(){return this._node}get tileWidth(){return this._tileWidth}get tileHeight(){return this._tileHeight}get pxWidth(){return this._node.width}get pxHeight(){return this._node.height}forChar(t){return this._map[t]||t.charCodeAt(0)%256}_configure(t){this._tileWidth=t.tileWidth||this.tileWidth,this._tileHeight=t.tileHeight||this.tileHeight,this.node.width=16*this.tileWidth,this.node.height=16*this.tileHeight,this._ctx.fillStyle="black",this._ctx.fillRect(0,0,this.pxWidth,this.pxHeight);const e=t.fontSize||t.size||Math.max(this.tileWidth,this.tileHeight);this._ctx.font=e+"px "+t.font,this._ctx.textAlign="center",this._ctx.textBaseline="middle",this._ctx.fillStyle="white"}draw(t,e){const i=t%16*this.tileWidth,s=Math.floor(t/16)*this.tileHeight,r=i+Math.floor(this.tileWidth/2),h=s+Math.floor(this.tileHeight/2);this._ctx.save(),this._ctx.beginPath(),this._ctx.rect(i,s,this.tileWidth,this.tileHeight),this._ctx.clip(),"function"==typeof e?e(this._ctx,i,s,this.tileWidth,this.tileHeight):(this._map[e]=t,this._ctx.fillText(e,r,h)),this._ctx.restore(),this.needsUpdate=!0}_initGlyphs(t=!1){for(let t=32;t<127;++t)this.draw(t,String.fromCharCode(t));t||([" ","☺","☻","♥","♦","♣","♠","☼","☀","★","☆","♂","♀","♪","♫","☸","▶","◀","↕","‼","⁋","☯","⌘","☖","↑","↓","→","←","Ω","↔","▲","▼"].forEach(((t,e)=>{this.draw(e,t)})),["⌂","⬉","✪","✘","☐","☑","◯","◎","⚐","⚑","▘","▖","▝","▗","❄","✭","✧","◣","◤","◢","◥","▨","▧","▚","♟","♜","♞","♝","♛","♚","〜","⚔","⚒","▶","▼","◀","▲","▤","▥","▦","╺","╻","╸","╹","▁","▔","▏","▕","✭","░","▒","▓","┃","┫","╡","╢","╖","╕","╣","║","╗","╝","╜","╛","┓","┗","┻","┳","┣","━","╋","╞","╟","╚","╔","╩","╦","╠","═","╬","╧","╨","╤","╥","╙","╘","╒","╓","╫","╪","┛","┏","█","▅","▌","▐","▀","α","β","Γ","π","Σ","σ","μ","τ","Φ","θ","Ω","δ","∞","θ","ε","η","Ξ","±","≥","≤","∴","∷","÷","≈","⋄","⋅","∗","➵","☠","☥","◼","◻"].forEach(((t,e)=>{this.draw(e+127,t)})))}}var n={random:Math.random.bind(Math)};class a{constructor(t=-1,e=0,i=0,s=0,r=0,h=0,n=0){this._data=[t,e,i,s,r,h,n]}static fromArray(t,e=!1){if(t.length<3)throw new Error("Colors must have 3 values.");return e&&(t=t.map((t=>Math.round(100*t/255)))),new this(t[0],t[1],t[2])}static fromString(t){if(!t.startsWith("#"))throw new Error('Color strings must be of form "#abc" or "#abcdef"');const e=Number.parseInt(t.substring(1),16);let i,s,r;return 4==t.length?(i=Math.round((e>>8)/15*100),s=Math.round(((240&e)>>4)/15*100),r=Math.round((15&e)/15*100)):(i=Math.round((e>>16)/255*100),s=Math.round(((65280&e)>>8)/255*100),r=Math.round((255&e)/255*100)),new this(i,s,r)}static fromNumber(t,e=!1){const i=new this;return i.fromInt(t,e),i}static make(t,e=!1){if(t instanceof this)return t.clone();if("string"==typeof t)return this.fromString(t);if(Array.isArray(t))return this.fromArray(t,e);if("number"==typeof t)return this.fromNumber(t,e);throw new Error("Failed to make color - unknown argument: "+JSON.stringify(t))}static from(t,e=!1){return t instanceof this?t:this.make(t,e)}get _r(){return this._data[0]}set _r(t){this._data[0]=t}get _g(){return this._data[1]}set _g(t){this._data[1]=t}get _b(){return this._data[2]}set _b(t){this._data[2]=t}get _rand(){return this._data[3]}get _redRand(){return this._data[4]}get _greenRand(){return this._data[5]}get _blueRand(){return this._data[6]}isNull(){return this._r<0}equals(t){"string"!=typeof t&&"number"!=typeof t||(t=a.from(t)),t instanceof a&&(t=t._data);const e=t;return this._data.every(((t,i)=>t==(e[i]||0)))}copy(t){return"string"!=typeof t&&"number"!=typeof t||(t=a.from(t)),t instanceof a&&(t=t._data),this.set(...t)}clone(){const t=new a;return t.copy(this),t}set(t=0,e=0,i=0,s=0,r=0,h=0,n=0){for(let t=0;t<this._data.length;++t)this._data[t]=arguments[t]||0;return this}nullify(){return this.set(-1,0,0)}blackOut(){return this.set(0,0,0)}toInt(t=!1){if(this.isNull())return-1;if(t){return((255&Math.round(this._r/100*255))<<16)+((255&Math.round(this._g/100*255))<<8)+(255&Math.round(this._b/100*255))}return((15&Math.round(this._r/100*15))<<8)+((15&Math.round(this._g/100*15))<<4)+(15&Math.round(this._b/100*15))}fromInt(t,e=!1){for(let t=0;t<this._data.length;++t)this._data[t]=0;return e?(this._r=Math.round(100*(t>>16)/255),this._g=Math.round(100*((65280&t)>>8)/255),this._b=Math.round(100*(255&t)/255),this):(this._r=Math.round(100*(t>>8)/15),this._g=Math.round(100*((240&t)>>4)/15),this._b=Math.round(100*(15&t)/15),this)}clamp(){if(!this.isNull())return this._r=Math.min(100,Math.max(0,this._r)),this._g=Math.min(100,Math.max(0,this._g)),this._b=Math.min(100,Math.max(0,this._b)),this}mix(t,e){this.isNull()&&this.blackOut(),"string"!=typeof t&&"number"!=typeof t||(t=a.from(t)),t instanceof a&&(t=t._data);const i=100-(e=Math.min(100,Math.max(0,e)));for(let s=0;s<this._data.length;++s)this._data[s]=Math.round((this._data[s]*i+t[s]*e)/100);return this}lighten(t){if(this.isNull())return this;if(0==(t=Math.min(100,Math.max(0,t))))return;const e=100-t;for(let i=0;i<3;++i)this._data[i]=Math.round((this._data[i]*e+100*t)/100);return this}darken(t){if(this.isNull())return this;if(0==(t=Math.min(100,Math.max(0,t))))return;const e=100-t;for(let i=0;i<3;++i)this._data[i]=Math.round((this._data[i]*e+0*t)/100);return this}bake(){if(this.isNull())return this;const t=this._rand?Math.floor(n.random()*this._rand):0,e=this._redRand?Math.floor(n.random()*this._redRand):0,i=this._greenRand?Math.floor(n.random()*this._greenRand):0,s=this._blueRand?Math.floor(n.random()*this._blueRand):0;this._r+=t+e,this._g+=t+i,this._b+=t+s;for(let t=3;t<this._data.length;++t)this._data[t]=0;return this}add(t,e=100){this.isNull()&&this.blackOut(),"string"!=typeof t&&"number"!=typeof t||(t=a.from(t)),t instanceof a&&(t=t._data);for(let i=0;i<this._data.length;++i)this._data[i]+=Math.round(t[i]*e/100);return this}scale(t){if(this.isNull())return this;t=Math.max(0,t);for(let e=0;e<this._data.length;++e)this._data[e]=Math.round(this._data[e]*t/100);return this}multiply(t){if(this.isNull())return this;"string"!=typeof t&&"number"!=typeof t||(t=a.from(t)),t instanceof a&&(t=t._data);for(let e=0;e<this._data.length;++e)this._data[e]=Math.round(this._data[e]*t[e]/100);return this}toString(t=!1){return this.isNull()?"null color":"#"+this.toInt(t).toString(16).padStart(t?6:3,"0")}}class o{constructor(){this.ch=0,this.fg=new a,this.bg=new a}copy(t){return this.ch=t.ch,this.fg.copy(t.fg),this.bg.copy(t.bg),this}clone(){const t=new o;return t.copy(this),t}nullify(){return this.ch=0,this.fg.nullify(),this.bg.nullify(),this}blackOut(){return this.ch=0,this.fg.blackOut(),this.bg.blackOut(),this}draw(t,e=100){if(!(e<=0))return t.ch&&(this.ch=t.ch),t.fg&&this.fg.mix(t.fg,e),t.bg&&this.bg.mix(t.bg,e),this}swapColors(){return[this.bg,this.fg]=[this.fg,this.bg],this}}var u={__proto__:null,Canvas:r,Glyphs:h,Buffer:class{constructor(t){this._canvas=t,this._data=new Uint32Array(t.width*t.height),t.copyTo(this)}get data(){return this._data}get width(){return this._canvas.width}get height(){return this._canvas.height}get(t,e){let i=e*this.width+t;const s=this._data[i]||0;return{glyph:s>>24,fg:4095&s,bg:s>>12&4095}}draw(t,e,i=-1,s=-1,r=-1){let h=e*this.width+t;const n=this._data[h]||0;"string"==typeof i&&(i=this._canvas.glyphs.forChar(i));const a=((i=i>=0?255&i:n>>24)<<24)+((r=r>=0?4095&r:n>>12&4095)<<12)+(s=s>=0?4095&s:4095&n);return this._data[h]=a,this}drawSprite(t,e,i){const s=i.ch?i.ch:-1,r=i.fg?i.fg.toInt():-1,h=i.bg?i.bg.toInt():-1;return this.draw(t,e,s,r,h)}blackOut(t,e){return this.draw(t,e,0,0,0)}fill(t=0,e=0,i=4095){"string"==typeof e&&(e=this._canvas.glyphs.forChar(e));const s=((e&=255)<<24)+((t&=4095)<<12)+(i&=4095);return this._data.fill(s),this}copy(t){return this._data.set(t._data),this}render(){return this._canvas.copy(this),this}copyFromCanvas(){return this._canvas.copyTo(this),this}},Color:a,Mixer:o,withImage:function(t){let e={};if("string"==typeof t)e.glyphs=h.fromImage(t);else if(t instanceof HTMLImageElement)e.glyphs=h.fromImage(t);else{if(!t.image)throw new Error("You must supply the image.");Object.assign(e,t),e.glyphs=h.fromImage(t.image)}return new r(e)},withFont:function(t){return"string"==typeof t&&(t={font:t}),t.glyphs=h.fromFont(t),new r(t)},configure:function(t={}){Object.assign(n,t)}};t.canvas=u,Object.defineProperty(t,"__esModule",{value:!0})}));
//# sourceMappingURL=gw-canvas.min.js.map
