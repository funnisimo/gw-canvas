!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).GW=t.GW||{})}(this,(function(t){"use strict";const e=[0,0,1,0,0,1,0,1,1,0,1,1];const i="\n#version 300 es\nin uvec2 position;\nin uvec2 uv;\nin uint style;\nout vec2 fsUv;\nflat out uint fsStyle;\nuniform highp uvec2 tileSize;\nuniform uvec2 viewportSize;\nvoid main() {\n\tivec2 positionPx = ivec2(position * tileSize);\n\tvec2 positionNdc = (vec2(positionPx * 2) / vec2(viewportSize))-1.0;\n\tpositionNdc.y *= -1.0;\n\tgl_Position = vec4(positionNdc, 0.0, 1.0);\n\tfsUv = vec2(uv);\n\tfsStyle = style;\n}".trim(),s="\n#version 300 es\nprecision highp float;\nin vec2 fsUv;\nflat in uint fsStyle;\nout vec4 fragColor;\nuniform sampler2D font;\nuniform highp uvec2 tileSize;\nvoid main() {\n\tuvec2 fontTiles = uvec2(textureSize(font, 0)) / tileSize;\n\n\tuint glyph = (fsStyle & uint(0xFF000000)) >> 24;\n\tuint glyphX = (glyph & uint(0xF));\n\tuint glyphY = (glyph >> 4);\n\tuvec2 fontPosition = uvec2(glyphX, glyphY);\n\n\tuvec2 fontPx = (tileSize * fontPosition) + uvec2(vec2(tileSize) * fsUv);\n\tvec3 texel = texelFetch(font, ivec2(fontPx), 0).rgb;\n\n\tfloat s = 15.0;\n\tuint fr = (fsStyle & uint(0xF00)) >> 8;\n\tuint fg = (fsStyle & uint(0x0F0)) >> 4;\n\tuint fb = (fsStyle & uint(0x00F)) >> 0;\n\tvec3 fgRgb = vec3(fr, fg, fb) / s;\n  \n\tuint br = (fsStyle & uint(0xF00000)) >> 20;\n\tuint bg = (fsStyle & uint(0x0F0000)) >> 26;\n\tuint bb = (fsStyle & uint(0x00F000)) >> 12;\n\tvec3 bgRgb = vec3(br, bg, bb) / s;\n  \n\tfragColor = vec4(mix(bgRgb, fgRgb, texel), 1.0);\n}".trim();class h{constructor(t={}){this._tileWidth=12,this._tileHeight=16,this.needsUpdate=!0,this._map={},t.font=t.font||"monospace",this._configure(t)}static fromImage(t){if("string"==typeof t){if(t.startsWith("data:"))throw new Error("Glyph: You must load a data string into an image element and use that.");const e=document.getElementById(t);if(!e)throw new Error("Glyph: Failed to find image element with id:"+t);t=e}const e=new this;return e.node.width=t.width,e.node.height=t.height,e._tileWidth=t.width/16,e._tileHeight=t.height/16,e._ctx.drawImage(t,0,0),e.needsUpdate=!0,e}static fromFont(t){"string"==typeof t&&(t={font:t});const e=new this(t),i=t.basicOnly||t.basic||!1;return e._initGlyphs(i),e}get tileWidth(){return this._tileWidth}get tileHeight(){return this._tileHeight}get pxWidth(){return this.node.width}get pxHeight(){return this.node.height}forChar(t){return this._map[t]||0}_configure(t){this.node=document.createElement("canvas"),this._ctx=this.node.getContext("2d"),this._tileWidth=t.tileWidth||this.tileWidth,this._tileHeight=t.tileHeight||this.tileHeight,this.node.width=16*this.tileWidth,this.node.height=16*this.tileHeight,this._ctx.fillStyle="black",this._ctx.fillRect(0,0,this.pxWidth,this.pxHeight);const e=t.fontSize||t.size||Math.max(this.tileWidth,this.tileHeight);this._ctx.font=e+"px "+t.font,this._ctx.textAlign="center",this._ctx.textBaseline="middle",this._ctx.fillStyle="white"}draw(t,e){const i=t%16*this.tileWidth,s=Math.floor(t/16)*this.tileHeight,h=i+Math.floor(this.tileWidth/2),n=s+Math.floor(this.tileHeight/2);this._ctx.save(),this._ctx.beginPath(),this._ctx.rect(i,s,this.tileWidth,this.tileHeight),this._ctx.clip(),"function"==typeof e?e(this._ctx,i,s,this.tileWidth,this.tileHeight):(this._map[e]=t,this._ctx.fillText(e,h,n)),this._ctx.restore(),this.needsUpdate=!0}_initGlyphs(t=!1){for(let t=32;t<127;++t)this.draw(t,String.fromCharCode(t));t||([" ","☺","☻","♥","♦","♣","♠","☼","☀","★","☆","♂","♀","♪","♫","☸","▶","◀","↕","‼","⁋","☯","⌘","☖","↑","↓","→","←","Ω","↔","▲","▼"].forEach(((t,e)=>{this.draw(e,t)})),["⌂","⬉","✪","✘","☐","☑","◯","◎","⚐","⚑","▘","▖","▝","▗","❄","✭","✧","◣","◤","◢","◥","▨","▧","▚","♟","♜","♞","♝","♛","♚","〜","⚔","⚒","▶","▼","◀","▲","▤","▥","▦","╺","╻","╸","╹","▁","▔","▏","▕","✭","░","▒","▓","┃","┫","╡","╢","╖","╕","╣","║","╗","╝","╜","╛","┓","┗","┻","┳","┣","━","╋","╞","╟","╚","╔","╩","╦","╠","═","╬","╧","╨","╤","╥","╙","╘","╒","╓","╫","╪","┛","┏","█","▅","▌","▐","▀","α","β","Γ","π","Σ","σ","μ","τ","Φ","θ","Ω","δ","∞","θ","ε","η","Ξ","±","≥","≤","∴","∷","÷","≈","⋄","⋅","∗","➵","☠","☥","◼","◻"].forEach(((t,e)=>{this.draw(e+127,t)})))}}class n{constructor(t){if(this._data=new Uint32Array,this._buffers={},this._attribs={},this._uniforms={},this._renderRequested=!1,this._autoRender=!0,this._width=50,this._height=25,!t.glyphs)throw new Error("You must supply glyphs for the canvas.");this._gl=this._initGL(t.node),this._configure(t)}get node(){return this._gl.canvas}get width(){return this._width}get height(){return this._height}get tileWidth(){return this._glyphs.tileWidth}get tileHeight(){return this._glyphs.tileHeight}get pxWidth(){return this.node.width}get pxHeight(){return this.node.height}get glyphs(){return this._glyphs}set glyphs(t){const e=this._gl,i=this._uniforms;t instanceof h||(t=h.fromImage(t)),(t!==this._glyphs||t.needsUpdate)&&(t!==this._glyphs&&(this._glyphs=t,this.resize(this._width,this._height),e.uniform2uiv(i.tileSize,[this.tileWidth,this.tileHeight])),this.uploadGlyphs())}_configure(t){this._width=t.width||this._width,this._height=t.height||this._height,this._autoRender=!1!==t.render,this.glyphs=t.glyphs}resize(t,e){this._width=t,this._height=e;const i=this.node;i.width=this._width*this.tileWidth,i.height=this._height*this.tileHeight;const s=this._gl,h=this._uniforms;s.viewport(0,0,i.width,i.height),s.uniform2ui(h.viewportSize,i.width,i.height),this._createGeometry(),this._createData()}draw(t,e,i,s,h){let n=e*this._width+t;n*=6;const r=((i&=255)<<24)+((h&=4095)<<12)+(s&=4095);this._data[n+2]=r,this._data[n+5]=r,this._requestRender()}copy(t){t.data.forEach(((t,e)=>{const i=6*e;this._data[i+2]=t,this._data[i+5]=t})),this._requestRender()}copyTo(t){const e=this.width*this.height,i=t.data;for(let t=0;t<e;++t){const e=6*t;i[t]=this._data[e+2]}}_initGL(t){if("string"==typeof t){const e=document.getElementById(t);if(!e)throw new Error("Failed to find canvas with id:"+t);if(!(e instanceof HTMLCanvasElement))throw new Error("Canvas: node must be a canvas element.");t=e}else t||(t=document.createElement("canvas"));let e=t.getContext("webgl2");if(!e)throw new Error("WebGL 2 not supported");const h=function(t,...e){const i=t.createProgram();if([t.VERTEX_SHADER,t.FRAGMENT_SHADER].forEach(((s,h)=>{const n=t.createShader(s);if(t.shaderSource(n,e[h]),t.compileShader(n),!t.getShaderParameter(n,t.COMPILE_STATUS))throw new Error(t.getShaderInfoLog(n));t.attachShader(i,n)})),t.linkProgram(i),!t.getProgramParameter(i,t.LINK_STATUS))throw new Error(t.getProgramInfoLog(i));return i}(e,i,s);e.useProgram(h);const n=e.getProgramParameter(h,e.ACTIVE_ATTRIBUTES);for(let t=0;t<n;t++){e.enableVertexAttribArray(t);let i=e.getActiveAttrib(h,t);this._attribs[i.name]=t}const r=e.getProgramParameter(h,e.ACTIVE_UNIFORMS);for(let t=0;t<r;t++){let i=e.getActiveUniform(h,t);this._uniforms[i.name]=e.getUniformLocation(h,i.name)}return e.uniform1i(this._uniforms.font,0),this._texture=function(t){let e=t.createTexture();return t.bindTexture(t.TEXTURE_2D,e),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.NEAREST),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.NEAREST),e}(e),e}_createGeometry(){const t=this._gl;this._buffers.position&&t.deleteBuffer(this._buffers.position),this._buffers.uv&&t.deleteBuffer(this._buffers.uv);let i=function(t,i,s,h){let n=s*h,r=new Uint16Array(n*e.length),o=new Uint8Array(n*e.length),a=0;for(let t=0;t<h;t++)for(let i=0;i<s;i++)e.forEach((e=>{r[a]=(a%2?t:i)+e,o[a]=e,a++}));const l=t.createBuffer();t.bindBuffer(t.ARRAY_BUFFER,l),t.vertexAttribIPointer(i.position,2,t.UNSIGNED_SHORT,0,0),t.bufferData(t.ARRAY_BUFFER,r,t.STATIC_DRAW);const f=t.createBuffer();return t.bindBuffer(t.ARRAY_BUFFER,f),t.vertexAttribIPointer(i.uv,2,t.UNSIGNED_BYTE,0,0),t.bufferData(t.ARRAY_BUFFER,o,t.STATIC_DRAW),{position:l,uv:f}}(t,this._attribs,this._width,this._height);Object.assign(this._buffers,i)}_createData(){const t=this._gl,e=this._attribs,i=this._width*this._height;this._buffers.style&&t.deleteBuffer(this._buffers.style),this._data=new Uint32Array(6*i);const s=t.createBuffer();t.bindBuffer(t.ARRAY_BUFFER,s),t.vertexAttribIPointer(e.style,1,t.UNSIGNED_INT,0,0),Object.assign(this._buffers,{style:s})}_requestRender(){!this._renderRequested&&this._autoRender&&(this._renderRequested=!0,requestAnimationFrame((()=>this._render())))}_render(){const t=this._gl;this._glyphs.needsUpdate&&this.uploadGlyphs(),this._renderRequested=!1,t.bindBuffer(t.ARRAY_BUFFER,this._buffers.style),t.bufferData(t.ARRAY_BUFFER,this._data,t.DYNAMIC_DRAW),t.drawArrays(t.TRIANGLES,0,this._width*this._height*6)}uploadGlyphs(){if(!this._glyphs.needsUpdate)return;const t=this._gl;t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,this._texture),t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,this._glyphs.node),this._requestRender(),this._glyphs.needsUpdate=!1}}var r={__proto__:null,Canvas:n,Glyphs:h,Buffer:class{constructor(t){this._canvas=t,this._data=new Uint32Array(t.width*t.height)}get data(){return this._data}get width(){return this._canvas.width}get height(){return this._canvas.height}draw(t,e,i,s,h){let n=e*this.width+t;const r=((i&=255)<<24)+((h&=4095)<<12)+(s&=4095);this._data[n]=r}drawChar(t,e,i,s,h){const n=this._canvas.glyphs.forChar(i);this.draw(t,e,n,s,h)}fill(t=0,e=4095,i=0){const s=((t&=255)<<24)+((i&=4095)<<12)+(e&=4095);this._data.fill(s)}copy(t){this._data.set(t._data)}},withImage:function(t){let e={};if("string"==typeof t)e.glyphs=h.fromImage(t);else if(t instanceof HTMLImageElement)e.glyphs=h.fromImage(t);else{if(!t.image)throw new Error("You must supply the image.");Object.assign(e,t),e.glyphs=h.fromImage(t.image)}return new n(e)},withFont:function(t){return"string"==typeof t&&(t={font:t}),t.glyphs=h.fromFont(t),new n(t)}};t.canvas=r,Object.defineProperty(t,"__esModule",{value:!0})}));
//# sourceMappingURL=gw-canvas-min.js.map
